// Code generated by counterfeiter. DO NOT EDIT.
package containerfakes

import (
	"sync"

	"code.cloudfoundry.org/winc/container"
	"code.cloudfoundry.org/winc/hcs"
	"github.com/Microsoft/hcsshim"
)

type FakeNetworkManager struct {
	AttachEndpointToConfigStub        func(hcsshim.ContainerConfig, string) (hcsshim.ContainerConfig, error)
	attachEndpointToConfigMutex       sync.RWMutex
	attachEndpointToConfigArgsForCall []struct {
		arg1 hcsshim.ContainerConfig
		arg2 string
	}
	attachEndpointToConfigReturns struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}
	attachEndpointToConfigReturnsOnCall map[int]struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}
	DeleteContainerEndpointsStub        func(hcs.Container, string) error
	deleteContainerEndpointsMutex       sync.RWMutex
	deleteContainerEndpointsArgsForCall []struct {
		arg1 hcs.Container
		arg2 string
	}
	deleteContainerEndpointsReturns struct {
		result1 error
	}
	deleteContainerEndpointsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteEndpointsByIdStub        func([]string, string) error
	deleteEndpointsByIdMutex       sync.RWMutex
	deleteEndpointsByIdArgsForCall []struct {
		arg1 []string
		arg2 string
	}
	deleteEndpointsByIdReturns struct {
		result1 error
	}
	deleteEndpointsByIdReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNetworkManager) AttachEndpointToConfig(arg1 hcsshim.ContainerConfig, arg2 string) (hcsshim.ContainerConfig, error) {
	fake.attachEndpointToConfigMutex.Lock()
	ret, specificReturn := fake.attachEndpointToConfigReturnsOnCall[len(fake.attachEndpointToConfigArgsForCall)]
	fake.attachEndpointToConfigArgsForCall = append(fake.attachEndpointToConfigArgsForCall, struct {
		arg1 hcsshim.ContainerConfig
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AttachEndpointToConfig", []interface{}{arg1, arg2})
	fake.attachEndpointToConfigMutex.Unlock()
	if fake.AttachEndpointToConfigStub != nil {
		return fake.AttachEndpointToConfigStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.attachEndpointToConfigReturns.result1, fake.attachEndpointToConfigReturns.result2
}

func (fake *FakeNetworkManager) AttachEndpointToConfigCallCount() int {
	fake.attachEndpointToConfigMutex.RLock()
	defer fake.attachEndpointToConfigMutex.RUnlock()
	return len(fake.attachEndpointToConfigArgsForCall)
}

func (fake *FakeNetworkManager) AttachEndpointToConfigArgsForCall(i int) (hcsshim.ContainerConfig, string) {
	fake.attachEndpointToConfigMutex.RLock()
	defer fake.attachEndpointToConfigMutex.RUnlock()
	return fake.attachEndpointToConfigArgsForCall[i].arg1, fake.attachEndpointToConfigArgsForCall[i].arg2
}

func (fake *FakeNetworkManager) AttachEndpointToConfigReturns(result1 hcsshim.ContainerConfig, result2 error) {
	fake.AttachEndpointToConfigStub = nil
	fake.attachEndpointToConfigReturns = struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) AttachEndpointToConfigReturnsOnCall(i int, result1 hcsshim.ContainerConfig, result2 error) {
	fake.AttachEndpointToConfigStub = nil
	if fake.attachEndpointToConfigReturnsOnCall == nil {
		fake.attachEndpointToConfigReturnsOnCall = make(map[int]struct {
			result1 hcsshim.ContainerConfig
			result2 error
		})
	}
	fake.attachEndpointToConfigReturnsOnCall[i] = struct {
		result1 hcsshim.ContainerConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeNetworkManager) DeleteContainerEndpoints(arg1 hcs.Container, arg2 string) error {
	fake.deleteContainerEndpointsMutex.Lock()
	ret, specificReturn := fake.deleteContainerEndpointsReturnsOnCall[len(fake.deleteContainerEndpointsArgsForCall)]
	fake.deleteContainerEndpointsArgsForCall = append(fake.deleteContainerEndpointsArgsForCall, struct {
		arg1 hcs.Container
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DeleteContainerEndpoints", []interface{}{arg1, arg2})
	fake.deleteContainerEndpointsMutex.Unlock()
	if fake.DeleteContainerEndpointsStub != nil {
		return fake.DeleteContainerEndpointsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteContainerEndpointsReturns.result1
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsCallCount() int {
	fake.deleteContainerEndpointsMutex.RLock()
	defer fake.deleteContainerEndpointsMutex.RUnlock()
	return len(fake.deleteContainerEndpointsArgsForCall)
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsArgsForCall(i int) (hcs.Container, string) {
	fake.deleteContainerEndpointsMutex.RLock()
	defer fake.deleteContainerEndpointsMutex.RUnlock()
	return fake.deleteContainerEndpointsArgsForCall[i].arg1, fake.deleteContainerEndpointsArgsForCall[i].arg2
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsReturns(result1 error) {
	fake.DeleteContainerEndpointsStub = nil
	fake.deleteContainerEndpointsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteContainerEndpointsReturnsOnCall(i int, result1 error) {
	fake.DeleteContainerEndpointsStub = nil
	if fake.deleteContainerEndpointsReturnsOnCall == nil {
		fake.deleteContainerEndpointsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContainerEndpointsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteEndpointsById(arg1 []string, arg2 string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deleteEndpointsByIdMutex.Lock()
	ret, specificReturn := fake.deleteEndpointsByIdReturnsOnCall[len(fake.deleteEndpointsByIdArgsForCall)]
	fake.deleteEndpointsByIdArgsForCall = append(fake.deleteEndpointsByIdArgsForCall, struct {
		arg1 []string
		arg2 string
	}{arg1Copy, arg2})
	fake.recordInvocation("DeleteEndpointsById", []interface{}{arg1Copy, arg2})
	fake.deleteEndpointsByIdMutex.Unlock()
	if fake.DeleteEndpointsByIdStub != nil {
		return fake.DeleteEndpointsByIdStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteEndpointsByIdReturns.result1
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdCallCount() int {
	fake.deleteEndpointsByIdMutex.RLock()
	defer fake.deleteEndpointsByIdMutex.RUnlock()
	return len(fake.deleteEndpointsByIdArgsForCall)
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdArgsForCall(i int) ([]string, string) {
	fake.deleteEndpointsByIdMutex.RLock()
	defer fake.deleteEndpointsByIdMutex.RUnlock()
	return fake.deleteEndpointsByIdArgsForCall[i].arg1, fake.deleteEndpointsByIdArgsForCall[i].arg2
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdReturns(result1 error) {
	fake.DeleteEndpointsByIdStub = nil
	fake.deleteEndpointsByIdReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) DeleteEndpointsByIdReturnsOnCall(i int, result1 error) {
	fake.DeleteEndpointsByIdStub = nil
	if fake.deleteEndpointsByIdReturnsOnCall == nil {
		fake.deleteEndpointsByIdReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEndpointsByIdReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNetworkManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachEndpointToConfigMutex.RLock()
	defer fake.attachEndpointToConfigMutex.RUnlock()
	fake.deleteContainerEndpointsMutex.RLock()
	defer fake.deleteContainerEndpointsMutex.RUnlock()
	fake.deleteEndpointsByIdMutex.RLock()
	defer fake.deleteEndpointsByIdMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNetworkManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ container.NetworkManager = new(FakeNetworkManager)
