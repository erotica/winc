// Code generated by counterfeiter. DO NOT EDIT.
package hcsfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/winc/hcs"
	"github.com/Microsoft/hcsshim"
)

type FakeContainer struct {
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct{}
	startReturns     struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	ShutdownStub        func() error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct{}
	shutdownReturns     struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	TerminateStub        func() error
	terminateMutex       sync.RWMutex
	terminateArgsForCall []struct{}
	terminateReturns     struct {
		result1 error
	}
	terminateReturnsOnCall map[int]struct {
		result1 error
	}
	WaitStub        func() error
	waitMutex       sync.RWMutex
	waitArgsForCall []struct{}
	waitReturns     struct {
		result1 error
	}
	waitReturnsOnCall map[int]struct {
		result1 error
	}
	WaitTimeoutStub        func(time.Duration) error
	waitTimeoutMutex       sync.RWMutex
	waitTimeoutArgsForCall []struct {
		arg1 time.Duration
	}
	waitTimeoutReturns struct {
		result1 error
	}
	waitTimeoutReturnsOnCall map[int]struct {
		result1 error
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	ResumeStub        func() error
	resumeMutex       sync.RWMutex
	resumeArgsForCall []struct{}
	resumeReturns     struct {
		result1 error
	}
	resumeReturnsOnCall map[int]struct {
		result1 error
	}
	HasPendingUpdatesStub        func() (bool, error)
	hasPendingUpdatesMutex       sync.RWMutex
	hasPendingUpdatesArgsForCall []struct{}
	hasPendingUpdatesReturns     struct {
		result1 bool
		result2 error
	}
	hasPendingUpdatesReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	StatisticsStub        func() (hcsshim.Statistics, error)
	statisticsMutex       sync.RWMutex
	statisticsArgsForCall []struct{}
	statisticsReturns     struct {
		result1 hcsshim.Statistics
		result2 error
	}
	statisticsReturnsOnCall map[int]struct {
		result1 hcsshim.Statistics
		result2 error
	}
	ProcessListStub        func() ([]hcsshim.ProcessListItem, error)
	processListMutex       sync.RWMutex
	processListArgsForCall []struct{}
	processListReturns     struct {
		result1 []hcsshim.ProcessListItem
		result2 error
	}
	processListReturnsOnCall map[int]struct {
		result1 []hcsshim.ProcessListItem
		result2 error
	}
	MappedVirtualDisksStub        func() (map[int]hcsshim.MappedVirtualDiskController, error)
	mappedVirtualDisksMutex       sync.RWMutex
	mappedVirtualDisksArgsForCall []struct{}
	mappedVirtualDisksReturns     struct {
		result1 map[int]hcsshim.MappedVirtualDiskController
		result2 error
	}
	mappedVirtualDisksReturnsOnCall map[int]struct {
		result1 map[int]hcsshim.MappedVirtualDiskController
		result2 error
	}
	CreateProcessStub        func(c *hcsshim.ProcessConfig) (hcsshim.Process, error)
	createProcessMutex       sync.RWMutex
	createProcessArgsForCall []struct {
		c *hcsshim.ProcessConfig
	}
	createProcessReturns struct {
		result1 hcsshim.Process
		result2 error
	}
	createProcessReturnsOnCall map[int]struct {
		result1 hcsshim.Process
		result2 error
	}
	OpenProcessStub        func(pid int) (hcsshim.Process, error)
	openProcessMutex       sync.RWMutex
	openProcessArgsForCall []struct {
		pid int
	}
	openProcessReturns struct {
		result1 hcsshim.Process
		result2 error
	}
	openProcessReturnsOnCall map[int]struct {
		result1 hcsshim.Process
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	closeReturns     struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ModifyStub        func(config *hcsshim.ResourceModificationRequestResponse) error
	modifyMutex       sync.RWMutex
	modifyArgsForCall []struct {
		config *hcsshim.ResourceModificationRequestResponse
	}
	modifyReturns struct {
		result1 error
	}
	modifyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainer) Start() error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct{}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startReturns.result1
}

func (fake *FakeContainer) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeContainer) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) StartReturnsOnCall(i int, result1 error) {
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Shutdown() error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct{}{})
	fake.recordInvocation("Shutdown", []interface{}{})
	fake.shutdownMutex.Unlock()
	if fake.ShutdownStub != nil {
		return fake.ShutdownStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.shutdownReturns.result1
}

func (fake *FakeContainer) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeContainer) ShutdownReturns(result1 error) {
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) ShutdownReturnsOnCall(i int, result1 error) {
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Terminate() error {
	fake.terminateMutex.Lock()
	ret, specificReturn := fake.terminateReturnsOnCall[len(fake.terminateArgsForCall)]
	fake.terminateArgsForCall = append(fake.terminateArgsForCall, struct{}{})
	fake.recordInvocation("Terminate", []interface{}{})
	fake.terminateMutex.Unlock()
	if fake.TerminateStub != nil {
		return fake.TerminateStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.terminateReturns.result1
}

func (fake *FakeContainer) TerminateCallCount() int {
	fake.terminateMutex.RLock()
	defer fake.terminateMutex.RUnlock()
	return len(fake.terminateArgsForCall)
}

func (fake *FakeContainer) TerminateReturns(result1 error) {
	fake.TerminateStub = nil
	fake.terminateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) TerminateReturnsOnCall(i int, result1 error) {
	fake.TerminateStub = nil
	if fake.terminateReturnsOnCall == nil {
		fake.terminateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.terminateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Wait() error {
	fake.waitMutex.Lock()
	ret, specificReturn := fake.waitReturnsOnCall[len(fake.waitArgsForCall)]
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct{}{})
	fake.recordInvocation("Wait", []interface{}{})
	fake.waitMutex.Unlock()
	if fake.WaitStub != nil {
		return fake.WaitStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitReturns.result1
}

func (fake *FakeContainer) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeContainer) WaitReturns(result1 error) {
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) WaitReturnsOnCall(i int, result1 error) {
	fake.WaitStub = nil
	if fake.waitReturnsOnCall == nil {
		fake.waitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) WaitTimeout(arg1 time.Duration) error {
	fake.waitTimeoutMutex.Lock()
	ret, specificReturn := fake.waitTimeoutReturnsOnCall[len(fake.waitTimeoutArgsForCall)]
	fake.waitTimeoutArgsForCall = append(fake.waitTimeoutArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("WaitTimeout", []interface{}{arg1})
	fake.waitTimeoutMutex.Unlock()
	if fake.WaitTimeoutStub != nil {
		return fake.WaitTimeoutStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitTimeoutReturns.result1
}

func (fake *FakeContainer) WaitTimeoutCallCount() int {
	fake.waitTimeoutMutex.RLock()
	defer fake.waitTimeoutMutex.RUnlock()
	return len(fake.waitTimeoutArgsForCall)
}

func (fake *FakeContainer) WaitTimeoutArgsForCall(i int) time.Duration {
	fake.waitTimeoutMutex.RLock()
	defer fake.waitTimeoutMutex.RUnlock()
	return fake.waitTimeoutArgsForCall[i].arg1
}

func (fake *FakeContainer) WaitTimeoutReturns(result1 error) {
	fake.WaitTimeoutStub = nil
	fake.waitTimeoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) WaitTimeoutReturnsOnCall(i int, result1 error) {
	fake.WaitTimeoutStub = nil
	if fake.waitTimeoutReturnsOnCall == nil {
		fake.waitTimeoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitTimeoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseReturns.result1
}

func (fake *FakeContainer) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakeContainer) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Resume() error {
	fake.resumeMutex.Lock()
	ret, specificReturn := fake.resumeReturnsOnCall[len(fake.resumeArgsForCall)]
	fake.resumeArgsForCall = append(fake.resumeArgsForCall, struct{}{})
	fake.recordInvocation("Resume", []interface{}{})
	fake.resumeMutex.Unlock()
	if fake.ResumeStub != nil {
		return fake.ResumeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resumeReturns.result1
}

func (fake *FakeContainer) ResumeCallCount() int {
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	return len(fake.resumeArgsForCall)
}

func (fake *FakeContainer) ResumeReturns(result1 error) {
	fake.ResumeStub = nil
	fake.resumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) ResumeReturnsOnCall(i int, result1 error) {
	fake.ResumeStub = nil
	if fake.resumeReturnsOnCall == nil {
		fake.resumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) HasPendingUpdates() (bool, error) {
	fake.hasPendingUpdatesMutex.Lock()
	ret, specificReturn := fake.hasPendingUpdatesReturnsOnCall[len(fake.hasPendingUpdatesArgsForCall)]
	fake.hasPendingUpdatesArgsForCall = append(fake.hasPendingUpdatesArgsForCall, struct{}{})
	fake.recordInvocation("HasPendingUpdates", []interface{}{})
	fake.hasPendingUpdatesMutex.Unlock()
	if fake.HasPendingUpdatesStub != nil {
		return fake.HasPendingUpdatesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasPendingUpdatesReturns.result1, fake.hasPendingUpdatesReturns.result2
}

func (fake *FakeContainer) HasPendingUpdatesCallCount() int {
	fake.hasPendingUpdatesMutex.RLock()
	defer fake.hasPendingUpdatesMutex.RUnlock()
	return len(fake.hasPendingUpdatesArgsForCall)
}

func (fake *FakeContainer) HasPendingUpdatesReturns(result1 bool, result2 error) {
	fake.HasPendingUpdatesStub = nil
	fake.hasPendingUpdatesReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) HasPendingUpdatesReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HasPendingUpdatesStub = nil
	if fake.hasPendingUpdatesReturnsOnCall == nil {
		fake.hasPendingUpdatesReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasPendingUpdatesReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Statistics() (hcsshim.Statistics, error) {
	fake.statisticsMutex.Lock()
	ret, specificReturn := fake.statisticsReturnsOnCall[len(fake.statisticsArgsForCall)]
	fake.statisticsArgsForCall = append(fake.statisticsArgsForCall, struct{}{})
	fake.recordInvocation("Statistics", []interface{}{})
	fake.statisticsMutex.Unlock()
	if fake.StatisticsStub != nil {
		return fake.StatisticsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.statisticsReturns.result1, fake.statisticsReturns.result2
}

func (fake *FakeContainer) StatisticsCallCount() int {
	fake.statisticsMutex.RLock()
	defer fake.statisticsMutex.RUnlock()
	return len(fake.statisticsArgsForCall)
}

func (fake *FakeContainer) StatisticsReturns(result1 hcsshim.Statistics, result2 error) {
	fake.StatisticsStub = nil
	fake.statisticsReturns = struct {
		result1 hcsshim.Statistics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) StatisticsReturnsOnCall(i int, result1 hcsshim.Statistics, result2 error) {
	fake.StatisticsStub = nil
	if fake.statisticsReturnsOnCall == nil {
		fake.statisticsReturnsOnCall = make(map[int]struct {
			result1 hcsshim.Statistics
			result2 error
		})
	}
	fake.statisticsReturnsOnCall[i] = struct {
		result1 hcsshim.Statistics
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) ProcessList() ([]hcsshim.ProcessListItem, error) {
	fake.processListMutex.Lock()
	ret, specificReturn := fake.processListReturnsOnCall[len(fake.processListArgsForCall)]
	fake.processListArgsForCall = append(fake.processListArgsForCall, struct{}{})
	fake.recordInvocation("ProcessList", []interface{}{})
	fake.processListMutex.Unlock()
	if fake.ProcessListStub != nil {
		return fake.ProcessListStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.processListReturns.result1, fake.processListReturns.result2
}

func (fake *FakeContainer) ProcessListCallCount() int {
	fake.processListMutex.RLock()
	defer fake.processListMutex.RUnlock()
	return len(fake.processListArgsForCall)
}

func (fake *FakeContainer) ProcessListReturns(result1 []hcsshim.ProcessListItem, result2 error) {
	fake.ProcessListStub = nil
	fake.processListReturns = struct {
		result1 []hcsshim.ProcessListItem
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) ProcessListReturnsOnCall(i int, result1 []hcsshim.ProcessListItem, result2 error) {
	fake.ProcessListStub = nil
	if fake.processListReturnsOnCall == nil {
		fake.processListReturnsOnCall = make(map[int]struct {
			result1 []hcsshim.ProcessListItem
			result2 error
		})
	}
	fake.processListReturnsOnCall[i] = struct {
		result1 []hcsshim.ProcessListItem
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) MappedVirtualDisks() (map[int]hcsshim.MappedVirtualDiskController, error) {
	fake.mappedVirtualDisksMutex.Lock()
	ret, specificReturn := fake.mappedVirtualDisksReturnsOnCall[len(fake.mappedVirtualDisksArgsForCall)]
	fake.mappedVirtualDisksArgsForCall = append(fake.mappedVirtualDisksArgsForCall, struct{}{})
	fake.recordInvocation("MappedVirtualDisks", []interface{}{})
	fake.mappedVirtualDisksMutex.Unlock()
	if fake.MappedVirtualDisksStub != nil {
		return fake.MappedVirtualDisksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.mappedVirtualDisksReturns.result1, fake.mappedVirtualDisksReturns.result2
}

func (fake *FakeContainer) MappedVirtualDisksCallCount() int {
	fake.mappedVirtualDisksMutex.RLock()
	defer fake.mappedVirtualDisksMutex.RUnlock()
	return len(fake.mappedVirtualDisksArgsForCall)
}

func (fake *FakeContainer) MappedVirtualDisksReturns(result1 map[int]hcsshim.MappedVirtualDiskController, result2 error) {
	fake.MappedVirtualDisksStub = nil
	fake.mappedVirtualDisksReturns = struct {
		result1 map[int]hcsshim.MappedVirtualDiskController
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) MappedVirtualDisksReturnsOnCall(i int, result1 map[int]hcsshim.MappedVirtualDiskController, result2 error) {
	fake.MappedVirtualDisksStub = nil
	if fake.mappedVirtualDisksReturnsOnCall == nil {
		fake.mappedVirtualDisksReturnsOnCall = make(map[int]struct {
			result1 map[int]hcsshim.MappedVirtualDiskController
			result2 error
		})
	}
	fake.mappedVirtualDisksReturnsOnCall[i] = struct {
		result1 map[int]hcsshim.MappedVirtualDiskController
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CreateProcess(c *hcsshim.ProcessConfig) (hcsshim.Process, error) {
	fake.createProcessMutex.Lock()
	ret, specificReturn := fake.createProcessReturnsOnCall[len(fake.createProcessArgsForCall)]
	fake.createProcessArgsForCall = append(fake.createProcessArgsForCall, struct {
		c *hcsshim.ProcessConfig
	}{c})
	fake.recordInvocation("CreateProcess", []interface{}{c})
	fake.createProcessMutex.Unlock()
	if fake.CreateProcessStub != nil {
		return fake.CreateProcessStub(c)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createProcessReturns.result1, fake.createProcessReturns.result2
}

func (fake *FakeContainer) CreateProcessCallCount() int {
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	return len(fake.createProcessArgsForCall)
}

func (fake *FakeContainer) CreateProcessArgsForCall(i int) *hcsshim.ProcessConfig {
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	return fake.createProcessArgsForCall[i].c
}

func (fake *FakeContainer) CreateProcessReturns(result1 hcsshim.Process, result2 error) {
	fake.CreateProcessStub = nil
	fake.createProcessReturns = struct {
		result1 hcsshim.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) CreateProcessReturnsOnCall(i int, result1 hcsshim.Process, result2 error) {
	fake.CreateProcessStub = nil
	if fake.createProcessReturnsOnCall == nil {
		fake.createProcessReturnsOnCall = make(map[int]struct {
			result1 hcsshim.Process
			result2 error
		})
	}
	fake.createProcessReturnsOnCall[i] = struct {
		result1 hcsshim.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) OpenProcess(pid int) (hcsshim.Process, error) {
	fake.openProcessMutex.Lock()
	ret, specificReturn := fake.openProcessReturnsOnCall[len(fake.openProcessArgsForCall)]
	fake.openProcessArgsForCall = append(fake.openProcessArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("OpenProcess", []interface{}{pid})
	fake.openProcessMutex.Unlock()
	if fake.OpenProcessStub != nil {
		return fake.OpenProcessStub(pid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openProcessReturns.result1, fake.openProcessReturns.result2
}

func (fake *FakeContainer) OpenProcessCallCount() int {
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	return len(fake.openProcessArgsForCall)
}

func (fake *FakeContainer) OpenProcessArgsForCall(i int) int {
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	return fake.openProcessArgsForCall[i].pid
}

func (fake *FakeContainer) OpenProcessReturns(result1 hcsshim.Process, result2 error) {
	fake.OpenProcessStub = nil
	fake.openProcessReturns = struct {
		result1 hcsshim.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) OpenProcessReturnsOnCall(i int, result1 hcsshim.Process, result2 error) {
	fake.OpenProcessStub = nil
	if fake.openProcessReturnsOnCall == nil {
		fake.openProcessReturnsOnCall = make(map[int]struct {
			result1 hcsshim.Process
			result2 error
		})
	}
	fake.openProcessReturnsOnCall[i] = struct {
		result1 hcsshim.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeContainer) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.closeReturns.result1
}

func (fake *FakeContainer) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeContainer) CloseReturns(result1 error) {
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) CloseReturnsOnCall(i int, result1 error) {
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Modify(config *hcsshim.ResourceModificationRequestResponse) error {
	fake.modifyMutex.Lock()
	ret, specificReturn := fake.modifyReturnsOnCall[len(fake.modifyArgsForCall)]
	fake.modifyArgsForCall = append(fake.modifyArgsForCall, struct {
		config *hcsshim.ResourceModificationRequestResponse
	}{config})
	fake.recordInvocation("Modify", []interface{}{config})
	fake.modifyMutex.Unlock()
	if fake.ModifyStub != nil {
		return fake.ModifyStub(config)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.modifyReturns.result1
}

func (fake *FakeContainer) ModifyCallCount() int {
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	return len(fake.modifyArgsForCall)
}

func (fake *FakeContainer) ModifyArgsForCall(i int) *hcsshim.ResourceModificationRequestResponse {
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	return fake.modifyArgsForCall[i].config
}

func (fake *FakeContainer) ModifyReturns(result1 error) {
	fake.ModifyStub = nil
	fake.modifyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) ModifyReturnsOnCall(i int, result1 error) {
	fake.ModifyStub = nil
	if fake.modifyReturnsOnCall == nil {
		fake.modifyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.modifyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.terminateMutex.RLock()
	defer fake.terminateMutex.RUnlock()
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	fake.waitTimeoutMutex.RLock()
	defer fake.waitTimeoutMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	fake.hasPendingUpdatesMutex.RLock()
	defer fake.hasPendingUpdatesMutex.RUnlock()
	fake.statisticsMutex.RLock()
	defer fake.statisticsMutex.RUnlock()
	fake.processListMutex.RLock()
	defer fake.processListMutex.RUnlock()
	fake.mappedVirtualDisksMutex.RLock()
	defer fake.mappedVirtualDisksMutex.RUnlock()
	fake.createProcessMutex.RLock()
	defer fake.createProcessMutex.RUnlock()
	fake.openProcessMutex.RLock()
	defer fake.openProcessMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ hcs.Container = new(FakeContainer)
